function Throw-Error($Message) {
    Write-Error $Message
    exit 1
}

try {
    [string]$ZipUrl = "https://10.32.20.128/public-archives/download/azarchive/IIS10_2019.zip"
    
    
    [int]$MinFreeGb = 50
    [string]$TargetDrive = 'E:'
    Write-Host "Validating $TargetDrive drive and free space..." -ForegroundColor Cyan

    $driveLetter = ($TargetDrive).TrimEnd(':','\')
    $targetPsDrive = Get-PSDrive -Name $driveLetter -ErrorAction SilentlyContinue
    if (-not $targetPsDrive) {
        Throw-Error "$TargetDrive drive not found. Please attach or mount a $TargetDrive volume."
    }

    $freeGb = [math]::Round(($targetPsDrive.Free / 1GB), 2)
    if ($freeGb -lt $MinFreeGb) {
        Throw-Error "Insufficient free space on $TargetDrive. Required: $MinFreeGb GB, Available: $freeGb GB."
    }

    Write-Host "$TargetDrive drive found with $freeGb GB free (>= $MinFreeGb GB required)." -ForegroundColor Green
  # Prepare directories on target drive
    $driveRoot = $targetPsDrive.Root
    $baseDir =  $driveRoot 
    $downloadDir = Join-Path $driveRoot 'IIS_download'
    $extractWorkDir = Join-Path $driveRoot 'IIS_extract_tmp'

   

  #  $null = New-Item -Path $baseDir -ItemType Directory -Force -ErrorAction Stop
    $null = New-Item -Path $downloadDir -ItemType Directory -Force -ErrorAction Stop

    # Download ZIP (bypass cert validation for internal/self-signed endpoints)
    $zipPath = Join-Path $downloadDir 'IIS10_2019.zip'
    $extractDir = $extractWorkDir

    Write-Host "Paths:" -ForegroundColor DarkCyan
    Write-Host "  Download dir: $downloadDir" -ForegroundColor DarkCyan
    Write-Host "  Zip path:     $zipPath" -ForegroundColor DarkCyan
    Write-Host "  Extract dir:  $extractDir" -ForegroundColor DarkCyan

    Write-Host "Downloading ZIP from: $ZipUrl" -ForegroundColor Yellow
    $prevCallback = [System.Net.ServicePointManager]::ServerCertificateValidationCallback
    $prevProto = [System.Net.ServicePointManager]::SecurityProtocol
    $prevExpect = [System.Net.ServicePointManager]::Expect100Continue
    [System.Net.ServicePointManager]::ServerCertificateValidationCallback = { $true }
    # Negotiate multiple TLS versions in case the server only supports older stacks
    [System.Net.ServicePointManager]::SecurityProtocol = (
        [System.Net.SecurityProtocolType]::Tls12 -bor 
        [System.Net.SecurityProtocolType]::Tls11 -bor 
        [System.Net.SecurityProtocolType]::Tls
    )
    [System.Net.ServicePointManager]::Expect100Continue = $false
    [System.Net.ServicePointManager]::DefaultConnectionLimit = 16

    $downloaded = $false
    try {
        # Retry Invoke-WebRequest a few times
        for ($i = 1; $i -le 3 -and -not $downloaded; $i++) {
            try {
                Invoke-WebRequest -Uri $ZipUrl -OutFile $zipPath -UseBasicParsing -ErrorAction Stop
                $downloaded = $true
            }
            catch {
                if ($i -eq 3) { throw }
                Start-Sleep -Seconds (2 * $i)
            }
        }
    }
    catch {
        Write-Warning ("Invoke-WebRequest failed, trying BITS. Error: {0}" -f $_.Exception.Message)
        try {
            # BITS is resilient to flaky networks and supports HTTPS
            Start-BitsTransfer -Source $ZipUrl -Destination $zipPath -Description "Download IIS package" -ErrorAction Stop
            $downloaded = $true
        }
        catch {
            Write-Warning ("BITS download failed. Error: {0}" -f $_.Exception.Message)
            # Final fallback: curl.exe with -k -L (ignore cert errors, follow redirects)
            $curlCmd = $null
            $curlCmdInfo = Get-Command curl.exe -ErrorAction SilentlyContinue
            if ($curlCmdInfo) { $curlCmd = $curlCmdInfo.Source } else { $curlCmd = "C:\\Windows\\System32\\curl.exe" }
            if (Test-Path -LiteralPath $curlCmd) {
                Write-Host ("Attempting curl fallback: '{0}'" -f $curlCmd) -ForegroundColor Yellow
                $curlArgs = @('-k','-L',"$ZipUrl",'-o',"$zipPath")
                $proc = Start-Process -FilePath $curlCmd -ArgumentList $curlArgs -NoNewWindow -PassThru -Wait
                if ($proc.ExitCode -eq 0 -and (Test-Path -LiteralPath $zipPath) -and ((Get-Item $zipPath).Length -gt 0)) {
                    $downloaded = $true
                }
                else {
                    Throw-Error ("curl.exe fallback failed. ExitCode={0}. URL='{1}'" -f $proc.ExitCode, $ZipUrl)
                }
            }
            else {
                Throw-Error ("Failed to download file via BITS as well, and curl.exe not found. URL='{0}'" -f $ZipUrl)
            }
        }
    }
    finally {
        [System.Net.ServicePointManager]::ServerCertificateValidationCallback = $prevCallback
        [System.Net.ServicePointManager]::SecurityProtocol = $prevProto
        [System.Net.ServicePointManager]::Expect100Continue = $prevExpect
    }
    Write-Host "Downloaded to: $zipPath" -ForegroundColor Green

    Write-Host "Extracting ZIP to: $extractDir" -ForegroundColor Yellow
    if (Test-Path $extractWorkDir) { Remove-Item -Path $extractWorkDir -Recurse -Force -ErrorAction SilentlyContinue }
    try {
        Expand-Archive -LiteralPath $zipPath -DestinationPath $extractDir -Force
    }
    catch {
        Throw-Error ("Failed to extract archive. ZipPath='{0}', Dest='{1}'. Error='{2}'" -f $zipPath, $extractDir, $_)
    }
    Write-Host "Extraction complete." -ForegroundColor Green

    # Determine content root (avoid copying the top-level folder itself)
    $contentRoot = $extractDir
    $topEntries = Get-ChildItem -LiteralPath $extractDir -Force | Where-Object { $_.Name -ne '__MACOSX' }
    if ($topEntries.Count -eq 1 -and $topEntries[0].PSIsContainer) {
        $contentRoot = $topEntries[0].FullName
    }

    Write-Host ("Moving extracted contents from '{0}' to '{1}'" -f $contentRoot, $baseDir) -ForegroundColor Yellow
    robocopy "$contentRoot" "$baseDir" *.* /E /NFL /NDL /NJH /NJS /NP | Out-Null

    # Cleanup downloaded artifacts
    try { if (Test-Path -LiteralPath $zipPath) { Remove-Item -LiteralPath $zipPath -Force -ErrorAction SilentlyContinue } } catch {}
    try { if (Test-Path -LiteralPath $downloadDir) { Remove-Item -LiteralPath $downloadDir -Recurse -Force -ErrorAction SilentlyContinue } } catch {}
    try { if (Test-Path -LiteralPath $extractWorkDir) { Remove-Item -LiteralPath $extractWorkDir -Recurse -Force -ErrorAction SilentlyContinue } } catch {}

    # Try to locate the installer script in common locations after extraction
    $candidateInstallPaths = @(
        (Join-Path (Join-Path $baseDir 'IIS10') 'install-iis10-script.ps1'),
        (Join-Path $baseDir 'install-iis10-script.ps1')
    )
    $installScript = $null
    foreach ($p in $candidateInstallPaths) { if (Test-Path -LiteralPath $p) { $installScript = $p; break } }
    if (-not (Test-Path $installScript)) {
        Throw-Error "Missing '$installScript'. Ensure your installer script exists in the repository under files/iis/."
    }

    Write-Host "Launching installer as Administrator: $installScript" -ForegroundColor Cyan
    $args = "-ExecutionPolicy Bypass -NoProfile -File `"$installScript`""
    Start-Process -FilePath "powershell.exe" -Verb RunAs -ArgumentList $args -Wait
    
     # Verify IIS (W3SVC) service is running
    Write-Host "Verifying IIS service (W3SVC) status..." -ForegroundColor Yellow
    
    $svc = Get-Service -Name W3SVC -ErrorAction SilentlyContinue
    if ($svc) {
        if ($svc.Status -ne 'Running') {
            try { Start-Service -Name W3SVC -ErrorAction Stop } catch { Write-Warning "Failed to start W3SVC: $($_.Exception.Message)" }
            $svc.Refresh()
        }
        Write-Host ("W3SVC status: {0}" -f $svc.Status) -ForegroundColor Green
    }
    else {
        Write-Warning "W3SVC service not found. Ensure IIS role installed successfully."
    }
    
    
    
    Write-Host "Bootstrap completed successfully." -ForegroundColor Cyan
    exit 0
   }
catch {
    Write-Error $_
    exit 1
}
