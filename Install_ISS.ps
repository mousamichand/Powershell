

function Throw-Error($Message) {
    Write-Error $Message
    exit 1
}

try {
    [string]$ZipUrl = "https://10.32.20.128/public-archives/download/IIS2019/IIS10_2019.zip"
    [int]$MinFreeGb = 50
    [string]$TargetDrive = 'E:'
    Write-Host "Validating $TargetDrive drive and free space..." -ForegroundColor Cyan

    $driveLetter = ($TargetDrive).TrimEnd(':','\')
    $targetPsDrive = Get-PSDrive -Name $driveLetter -ErrorAction SilentlyContinue
    if (-not $targetPsDrive) {
        Throw-Error "$TargetDrive drive not found. Please attach or mount a $TargetDrive volume."
    }

    $freeGb = [math]::Round(($targetPsDrive.Free / 1GB), 2)
    if ($freeGb -lt $MinFreeGb) {
        Throw-Error "Insufficient free space on $TargetDrive. Required: $MinFreeGb GB, Available: $freeGb GB."
    }

    Write-Host "$TargetDrive drive found with $freeGb GB free (>= $MinFreeGb GB required)." -ForegroundColor Green

    # Prepare directories on target drive
    $driveRoot = $targetPsDrive.Root
    $baseDir = Join-Path $driveRoot 'iis'
    $downloadDir = Join-Path $driveRoot 'IIS'

    # Validate that paths are legal before use
    foreach ($p in @($baseDir, $downloadDir)) {
        if (-not [System.IO.Path]::IsPathRooted($p)) { Throw-Error "Computed path is not rooted: '$p'" }
        if (-not (Test-Path -LiteralPath (Split-Path -Path $p -Qualifier))) { Throw-Error "Drive in path does not exist: '$p'" }
    }

    $null = New-Item -Path $baseDir -ItemType Directory -Force -ErrorAction Stop
    $null = New-Item -Path $downloadDir -ItemType Directory -Force -ErrorAction Stop

    # Download ZIP (bypass cert validation for internal/self-signed endpoints)
    $zipPath = Join-Path $downloadDir 'IIS10_2019.zip'
    $extractDir = Join-Path $driveRoot 'IIS10_2019'

    Write-Host "Paths:" -ForegroundColor DarkCyan
    Write-Host "  Download dir: $downloadDir" -ForegroundColor DarkCyan
    Write-Host "  Zip path:     $zipPath" -ForegroundColor DarkCyan
    Write-Host "  Extract dir:  $extractDir" -ForegroundColor DarkCyan

    Write-Host "Downloading ZIP from: $ZipUrl" -ForegroundColor Yellow
    $prevCallback = [System.Net.ServicePointManager]::ServerCertificateValidationCallback
    $prevProto = [System.Net.ServicePointManager]::SecurityProtocol
    $prevExpect = [System.Net.ServicePointManager]::Expect100Continue
    [System.Net.ServicePointManager]::ServerCertificateValidationCallback = { $true }
    # Negotiate multiple TLS versions in case the server only supports older stacks
    [System.Net.ServicePointManager]::SecurityProtocol = (
        [System.Net.SecurityProtocolType]::Tls12 -bor 
        [System.Net.SecurityProtocolType]::Tls11 -bor 
        [System.Net.SecurityProtocolType]::Tls
    )
    [System.Net.ServicePointManager]::Expect100Continue = $false
    [System.Net.ServicePointManager]::DefaultConnectionLimit = 16

    $downloaded = $false
    try {
        # Retry Invoke-WebRequest a few times
        for ($i = 1; $i -le 3 -and -not $downloaded; $i++) {
            try {
                Invoke-WebRequest -Uri $ZipUrl -OutFile $zipPath -UseBasicParsing -ErrorAction Stop
                $downloaded = $true
            }
            catch {
                if ($i -eq 3) { throw }
                Start-Sleep -Seconds (2 * $i)
            }
        }
    }
    catch {
        Write-Warning ("Invoke-WebRequest failed, trying BITS. Error: {0}" -f $_.Exception.Message)
        try {
            # BITS is resilient to flaky networks and supports HTTPS
            Start-BitsTransfer -Source $ZipUrl -Destination $zipPath -Description "Download IIS package" -ErrorAction Stop
            $downloaded = $true
        }
        catch {
            Write-Warning ("BITS download failed. Error: {0}" -f $_.Exception.Message)
            # Final fallback: curl.exe with -k -L (ignore cert errors, follow redirects)
            $curlCmd = $null
            $curlCmdInfo = Get-Command curl.exe -ErrorAction SilentlyContinue
            if ($curlCmdInfo) { $curlCmd = $curlCmdInfo.Source } else { $curlCmd = "C:\\Windows\\System32\\curl.exe" }
            if (Test-Path -LiteralPath $curlCmd) {
                Write-Host ("Attempting curl fallback: '{0}'" -f $curlCmd) -ForegroundColor Yellow
                $curlArgs = @('-k','-L',"$ZipUrl",'-o',"$zipPath")
                $proc = Start-Process -FilePath $curlCmd -ArgumentList $curlArgs -NoNewWindow -PassThru -Wait
                if ($proc.ExitCode -eq 0 -and (Test-Path -LiteralPath $zipPath) -and ((Get-Item $zipPath).Length -gt 0)) {
                    $downloaded = $true
                }
                else {
                    Throw-Error ("curl.exe fallback failed. ExitCode={0}. URL='{1}'" -f $proc.ExitCode, $ZipUrl)
                }
            }
            else {
                Throw-Error ("Failed to download file via BITS as well, and curl.exe not found. URL='{0}'" -f $ZipUrl)
            }
        }
    }
    finally {
        [System.Net.ServicePointManager]::ServerCertificateValidationCallback = $prevCallback
        [System.Net.ServicePointManager]::SecurityProtocol = $prevProto
        [System.Net.ServicePointManager]::Expect100Continue = $prevExpect
    }
    Write-Host "Downloaded to: $zipPath" -ForegroundColor Green

    Write-Host "Extracting ZIP to: $extractDir" -ForegroundColor Yellow
    if (Test-Path $extractDir) { Remove-Item -Path $extractDir -Recurse -Force -ErrorAction SilentlyContinue }
    try {
        Expand-Archive -LiteralPath $zipPath -DestinationPath $extractDir -Force
    }
    catch {
        Throw-Error ("Failed to extract archive. ZipPath='{0}', Dest='{1}'. Error='{2}'" -f $zipPath, $extractDir, $_)
    }
    Write-Host "Extraction complete." -ForegroundColor Green

    # Copy this folder's contents (dependent files) to D:\iis
    $sourceDir = $PSScriptRoot
    if ([string]::IsNullOrWhiteSpace($sourceDir)) {
        $sourceDir = Split-Path -Parent -Path $MyInvocation.MyCommand.Path
    }
    if (-not (Test-Path -LiteralPath $sourceDir)) { Throw-Error ("Cannot resolve script root for dependency copy. Resolved='{0}'" -f $sourceDir) }

    Write-Host "Copying scripts and dependencies from '$sourceDir' to '$baseDir'..." -ForegroundColor Yellow
    robocopy "$sourceDir" "$baseDir" *.* /E /NFL /NDL /NJH /NJS /NP | Out-Null
    Write-Host "Copy complete." -ForegroundColor Green

    $installScript = Join-Path $baseDir 'install-iis10-script.ps1'
    if (-not (Test-Path $installScript)) {
        Throw-Error "Missing '$installScript'. Ensure your installer script exists in the repository under files/iis/."
    }

    Write-Host "Launching installer as Administrator: $installScript" -ForegroundColor Cyan
    $args = "-ExecutionPolicy Bypass -NoProfile -File `"$installScript`""
    Start-Process -FilePath "powershell.exe" -Verb RunAs -ArgumentList $args -Wait

    Write-Host "Bootstrap completed successfully." -ForegroundColor Cyan
    exit 0
}
catch {
    Write-Error $_
    exit 1
}


